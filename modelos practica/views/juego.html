<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nivel Hielo</title>
    <style>
        body { margin: 0; }
    </style>
</head>
<body>

<script type="module">
  import * as THREE from './three.module.js';
  import { OrbitControls } from './OrbitControls.js';
  import { GLTFLoader } from './GLTFLoader.js';
  import { STLLoader } from "./STLLoader.js";
  import Player from './scripts/player.js';
  import PlayerControls from './scripts/playerControls.js';
  
  import { checkPlayerCollisions } from './scripts/physics.js';
  const scene = new THREE.Scene();
  const loader = new THREE.TextureLoader();
  
  let rayoModel = null;
  let player = null;
  let collidableObjects = [];
  
  loader.load('./fondo hielo.jpg', function (texture) {
    scene.background = texture;
  });

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 45, 5);

  const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
  scene.add(hemisphereLight);

  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.domElement.tabIndex = '0';
  document.body.appendChild(renderer.domElement);
  renderer.domElement.focus();
  new OrbitControls(camera, renderer.domElement);
  

  const mixers = [];
  const loaderGLTF = new GLTFLoader();
  const clock = new THREE.Clock();
  const textureLoader = new THREE.TextureLoader();
  
  async function init() {
    // Cargar el entorno
    const terreno = await cargarModeloEnPosicion('./modelos/low-poly_ice_world.glb', new THREE.Vector3(0, 0, 0), new THREE.Vector3(1.3, 1.3, 1.3),0);
    const iceTexture = textureLoader.load('./modelos/iceTex.jpg', function (texture) {
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(1, 1); 

    // Asignar la textura de hielo al material del terreno
    terreno.traverse(function (child) {
        if (child.isMesh) {
            child.material.map = texture;
            child.material.needsUpdate = true;
        }
      });
    });
    // Cargar objetos estáticos 
    const posicionesPinos = [
      new THREE.Vector3(-20, 0, 0),
      new THREE.Vector3(3, 0.5, -17),
      new THREE.Vector3(20, 0, 4),
      new THREE.Vector3(20, 0, 0),
      new THREE.Vector3(0, 0, -20),
      new THREE.Vector3(0, 0.5, 20),    
     
      
    ];
    
    
    posicionesPinos.forEach(pos => cargarModeloEnPosicion('./modelos/pino.glb', pos, new THREE.Vector3(0.8, 0.8, 0.8),1));

    // Cargar objetos animados 
    cargarModeloEnPosicion('./modelos/PolarBear.glb', new THREE.Vector3(15, 1.5, -17), new THREE.Vector3(0.5, 0.5, 0.5),1);
    cargarModeloEnPosicion('./modelos/rayo.glb', new THREE.Vector3(3, 1.5, 3), new THREE.Vector3(0.5, 0.5, 0.5),1);
    cargarModeloEnPosicion('./modelos/StaticZorro.glb', new THREE.Vector3(-4, 0.5, 1), new THREE.Vector3(0.5, 0.5, 0.5),1);
    cargarModeloEnPosicion('./modelos/StaticConejo.glb', new THREE.Vector3(3, 0.5, 2), new THREE.Vector3(0.5, 0.5, 0.5),1);
    initPlayer(terreno);
    // Iniciar la animación después de cargar todos los modelos
    requestAnimationFrame(animate);
  }
  
  async function initPlayer(terrainMesh) {
    const playerGeometry = new THREE.BoxGeometry(1, 1, 1); 
   
    const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xFF5733 });
    const playerMaterial2 = new THREE.MeshBasicMaterial({ color: 0xAA5733 });
    
    const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
    //const playerMesh = await cargarModelo(playerModel);
    //  const playerMesh2 = await cargarModelo(playerModel2);
    //const playerMesh2 = new THREE.Mesh(playerGeometry, playerMaterial2);
    playerMesh.position.set(0, 6, 0); // La posición inicial del jugador en la escena
    //playerMesh2.position.set(2, 2, 0);
   
    

    
    renderer.domElement.tabIndex = '0';
    renderer.domElement.focus();


    const playerControls = new PlayerControls(camera, renderer.domElement);
    
    player = new Player(1,playerMesh,"Zorro", playerControls, scene, terrainMesh);
    
   
    scene.add(playerMesh);
    
    
  }


  
  function cargarModeloEnPosicion(url, posicion, escala, esColisionable ) {
  return loaderGLTF.loadAsync(url).then(gltf => {
    const obj = gltf.scene;
    obj.position.copy(posicion);
    obj.scale.copy(escala);
    scene.add(obj);
    if (gltf.animations.length > 0) {
      const mixer = new THREE.AnimationMixer(obj);
      gltf.animations.forEach(clip => {
        mixer.clipAction(clip).play();
      });
      mixers.push(mixer);
    }
    if (esColisionable) {
      const hitbox = new THREE.Box3().setFromObject(obj);
      obj.userData.hitbox = hitbox; 
      collidableObjects.push(obj); 
    }
    return obj; 
  });
}

  async function cargarModelo(url) {
   const gltf = await loaderGLTF.loadAsync(url);
   const model = gltf.scene;
   return { scene: gltf.scene, animations: gltf.animations };
  }


  

  function cargarRayo(posicion) {
  loaderGLTF.load('./modelos/rayo.glb', function (model) {
    const obj = model.scene;
    obj.position.copy(posicion);
    obj.scale.set(0.8, 0.5, 0.8);
    scene.add(obj);
    rayoModel = obj; 
  });
  }

  

  let lastFrameTime = Date.now();
  
  function animate() {
    requestAnimationFrame(animate);
    let players = [];
    const now = Date.now();
    const deltaTime = clock.getDelta(); // tiempo en segundos
    

    // Actualizar todos los mixers
    mixers.forEach(mixer => mixer.update(deltaTime));
    if (player) {
        player.update(deltaTime); 
        players.push(player); 
    }
    
    checkPlayerCollisions(player, collidableObjects);
    if (rayoModel) {
    rayoModel.rotation.y += 0.01; 
  }
    renderer.render(scene, camera);
  }
  init();
  
</script>

</body>
</html>
